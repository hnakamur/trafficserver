# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
msgid ""
msgstr ""
"Project-Id-Version: Apache Traffic Server 4.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-11-08 17:57+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sdk/new-protocol-plugins.en.rst:4
msgid "New Protocol Plugins"
msgstr "新規プロトコルプラグイン"

#: ../../sdk/new-protocol-plugins.en.rst:26
msgid ""
"The new protocol APIs enable you to extend Traffic Server to be a web proxy "
"for any protocol. This chapter describes new protocol APIs and the plugins "
"that support new protocols. It also provides a detailed review of code for "
"a sample Protocol plugin that supports a very simple artificial HTTP-like "
"protocol."
msgstr ""
"新規プロトコルプラグインは Traffic Server を任意のプロトコルのウェブプロキ"
"シーに拡張することを可能にします。この章では新規プロトコル API と新規プロト"
"コルをサポートするプラグインについて説明します。また非常にシンプルな模造の "
"HTTP ライクなプロトコルをサポートするサンプルプロトコルプラグインのコードの"
"詳細なレビューも示します。"

#: ../../sdk/new-protocol-plugins.en.rst:35
msgid "About the Sample Protocol"
msgstr "サンプルプロトコルについて"

#: ../../sdk/new-protocol-plugins.en.rst:37
msgid ""
"The sample protocol enables a client to ask a server for a file. Clients "
"send requests to a specific Traffic Server port (specified in :file:`plugin."
"config`); each request has the following structure::"
msgstr ""
"サンプルプロトコルはクライアントがサーバーにファイルを問い合わせることを可能"
"にします。クライアントは特定の Traffic Server ポート（ :file:`plugin."
"config` で指定される）にリクエストを送信します。各リクエストは下記の構造を持"
"ちます。"

#: ../../sdk/new-protocol-plugins.en.rst:52
msgid "In more specific terms, Traffic Server and the Protocol plugin must:"
msgstr ""
"より具体的には、 Traffic Server とプロトコルプラグインは下記の処理をする必要"
"があります。:"

#: ../../sdk/new-protocol-plugins.en.rst:54
msgid ""
"Listen for and accept client connections (on the accept port specified in :"
"file:`plugin.config`)"
msgstr ""
"クライアントコネクションの listen と accept を行う。（サーバーポートは :"
"file:`plugin.config` で指定される）"

#: ../../sdk/new-protocol-plugins.en.rst:57
msgid "Read incoming client requests"
msgstr "やってきたクライアントリクエストを読込む"

#: ../../sdk/new-protocol-plugins.en.rst:59
msgid "Look up the requested content in the Traffic Server cache"
msgstr ""
"リクエストされたコンテンツを、 Traffic Server キャッシュ内でルックアップする"

#: ../../sdk/new-protocol-plugins.en.rst:61
msgid ""
"Serve content from cache if the request is a cache hit (this simple example "
"does not do freshness checking)"
msgstr ""
"リクエストがキャッシュヒットした場合、キャッシュからコンテンツを配信する。"
"（このシンプルな例では新鮮さのチェックを行わない）"

#: ../../sdk/new-protocol-plugins.en.rst:64
msgid ""
"Open a connection to the origin server if the request is a cache miss (on "
"the server port specified in :file:`plugin.config`)"
msgstr ""
"リクエストがキャッシュミスした場合、オリジンサーバーとのコネクションを開く。"
"（サーバーポートは :file:`plugin.config` で指定される）"

#: ../../sdk/new-protocol-plugins.en.rst:67
msgid "Forward the request to the origin server"
msgstr "オリジンサーバーへリクエストを転送する。"

#: ../../sdk/new-protocol-plugins.en.rst:69
msgid "Receive the origin server response"
msgstr "オリジンサーバーのレスポンスを受け取る。"

#: ../../sdk/new-protocol-plugins.en.rst:71
msgid "Cache the response and send it on to the client"
msgstr "レスポンスをキャッシュし、クライアントに送信する。"

#: ../../sdk/new-protocol-plugins.en.rst:80
msgid "Sample Protocol State Diagram"
msgstr "サンプルプロトコルの状態遷移図"

#: ../../sdk/new-protocol-plugins.en.rst:83
msgid "Protocol Plugin Structure"
msgstr "プロトコルプラグインの構造"

#: ../../sdk/new-protocol-plugins.en.rst:94
msgid "Continuations in the Protocol Plugin"
msgstr "プロトコルプラグインにおける継続"

#: ../../sdk/new-protocol-plugins.en.rst:110
msgid "**Protocol Plugin Overview**"
msgstr "**プロトコルプラグイン概要**"

#: ../../sdk/new-protocol-plugins.en.rst:117
msgid "Protocol Plugin Overview"
msgstr "プロトコルプラグイン概要"

#: ../../sdk/new-protocol-plugins.en.rst:119
msgid ""
"The first steps for writing the Protocol plugin are now clear: in "
"``TSPluginInit``, you must create a continuation that listens for net "
"connections on the client port specified in :file:`plugin.config` (this "
"continuation is the accept state machine)."
msgstr ""
"プロトコルプラグインの記述の最初のステップは明確です。 ``TSPluginInit`` "
"で、 :file:`plugin.config` で指定されたクライアントポートでネットコネクショ"
"ンを listen する継続を生成しなければなりません。（この継続は accept ステート"
"マシンです）"

#: ../../sdk/new-protocol-plugins.en.rst:124
msgid ""
"Below is a summary of the continuations implemented for the Protocol plugin:"
msgstr "下記はプロトコルプラグインの為に実装される継続の概要です:"

#: ../../sdk/new-protocol-plugins.en.rst:127
msgid ""
"An **accept state machine** that listens for client connections, and then "
"creates transaction state machines whenever Traffic Server accepts a new "
"client connection. The accept state machine lives as long as Traffic Server "
"is running."
msgstr ""
"クライアントコネクションを listen し、 Traffic Server が新しいクライアントコ"
"ネクションを accept する度にトランザクションステートマシンを生成する "
"**accept ステートマシン** 。 accept ステートマシンは Traffic Server が動作し"
"ている限り残ります。"

#: ../../sdk/new-protocol-plugins.en.rst:132
msgid ""
"**Transaction state machines** that read client requests, process them, and "
"are then destroyed when the transaction is finished."
msgstr ""
"クライアントリクエストを読込み、処理し、トランザクションが終了した際に破棄さ"
"れる **トランザクションステートマシン**"

#: ../../sdk/new-protocol-plugins.en.rst:136
msgid "Event Flow"
msgstr "イベントフロー"

#: ../../sdk/new-protocol-plugins.en.rst:138
msgid ""
"Implementing the rest of the Protocol plugin requires that you understand "
"the flow of events during the course of a transaction. Unlike HTTP "
"transaction plugins, this plugin must read data from network connections "
"and then read/write data to the Traffic Server cache. This means that its "
"continuations do not receive HTTP state machine events; they receive events "
"from Traffic Server's processor subsystems. For example: the accept state "
"machine is activated by an ``TS_EVENT_NET_ACCEPT`` event from Traffic "
"Server's Net Processor; the handler function for the accept state machine "
"must therefore be able to handle that event."
msgstr ""
"プロトコルプラグインの残りの実装には、トランザクションの過程の中のイベントの"
"フローの理解が求められます。 HTTP トランザクションプラグインとは異なり、この"
"プラグインはネットワークコネクションからデータを読込み、 Traffic Server "
"キャッシュへデータを読込み/書込みしなければなりません。これは、その継続は "
"HTTP ステートマシンのイベントを受け取らず、 Traffic Server のプロセッサーサ"
"ブシステムからイベントを受け取ることを意味します。例えば accept ステートマシ"
"ンは、Traffic Server のネットプロセッサーからのイベント "
"``TS_EVENT_NET_ACCEPT`` によって始動します。 accept ステートマシンのハンド"
"ラー関数はそのため、このイベントを処理できなければなりません。"

#: ../../sdk/new-protocol-plugins.en.rst:149
msgid ""
"The transaction state machines are activated when the client connection "
"receives incoming request data. The **Net Processor** notifies the "
"transaction state machine of incoming data. The transaction state machine "
"reads the data; when finished, it initiates a cache lookup of the requested "
"file. When the cache lookup completes, the transaction state machine is "
"activated by the Traffic Server **Cache Processor**."
msgstr ""
"トランザクションステートマシンはクライアントコネクションがやって来たリクエス"
"トデータを受信した際に始動します。 **ネットプロセッサー** はやって来たデータ"
"のトランザクションステートマシンに通知します。トランザクションステートマシン"
"はそのデータを読込み、それが終了した際にリクエストされたファイルのキャッシュ"
"ルックアップを開始します。キャッシュルックアップが完了した際、トランザクショ"
"ンステートマシンは Traffic Server の **キャッシュプロセッサー** によって始動"
"します。"

#: ../../sdk/new-protocol-plugins.en.rst:156
msgid ""
"If the transaction state machine needs to open a connection to the origin "
"server to fetch content (in the case of a cache miss), then the transaction "
"state machine initiates a DNS lookup of the server name. The transaction "
"state machine is activated by a DNS lookup event from the Traffic Server "
"**Host Database Processor**. If the transaction must connect to the origin "
"server, then the transaction state machine initiates a net connection and "
"waits for an event from the Net Processor."
msgstr ""
"トランザクションステートマシンがコンテンツを取得するためオリジンサーバーへの"
"コネクションを開く必要がある場合（キャッシュミスした場合）、トランザクション"
"ステートマシンはサーバー名の DNS ルックアップを開始します。トランザクション"
"ステートマシンは Traffic Server の **ホストデータベースプロセッサー** から"
"の DNS ルックアップイベントによって始動します。トランザクションがオリジン"
"サーバーへ接続しなければならない場合、トランザクションステートマシンはネット"
"コネクションを開始し、ネットプロセッサーからのイベントを待ちます。"

#: ../../sdk/new-protocol-plugins.en.rst:165
msgid "**Protocol Plugin Flow of Events**"
msgstr "**プロトコルプラグインのイベントのフロー**"

#: ../../sdk/new-protocol-plugins.en.rst:172
msgid "Protocol Plugin Flow of Events"
msgstr "プロトコルプラグインのイベントのフロー"

#: ../../sdk/new-protocol-plugins.en.rst:179
msgid ""
"Notice that this flow of events is independent of the Protocol plugin's "
"design (i.e., whether you build **accept** or **transaction** state "
"machines). Any plugin that supports network connections uses the net "
"vconnection interfaces (``TSNetAccept``, ``TSNetConnect``) and thus "
"receives events from the Net Processor. Any plugin that performs cache "
"lookups or cache writes uses ``TSCacheRead``, ``TSCacheWrite``, "
"``TSVConnRead``, and ``TSVConnWrite`` and thus receives events from the "
"Cache Processor and Traffic Server event system. Similarly, any plugin that "
"does DNS lookups receives events from the Host Database Processor."
msgstr ""
"このイベントのフローは、プロトコルプラグインの設計（すなわち、 **accept** ス"
"テートマシンや **トランザクション** ステートマシンの組み立て）とは独立してい"
"ることに注意してください。ネットワークコネクションをサポートするプラグイン"
"は net vconnection インタフェース（ ``TSNetAccept``, ``TSNetConnect`` ） を"
"使用し、それによってネットプロセッサーからイベントを受け取ります。キャッシュ"
"ルックアップやキャッシュ書込みを行うプラグインは、 ``TSCacheRead`` 、 "
"``TSCacheWrite`` 、 ``TSVConnRead`` 、 そして ``TSVConnWrite`` を使用し、そ"
"れによってキャッシュプロセッサーと Traffic Server イベントシステムからイベン"
"トを受け取ります。同様に DNS ルックアップを行うプラグインはホストデータベー"
"スプロセッサーからイベントを受け取ります。"

#: ../../sdk/new-protocol-plugins.en.rst:192
msgid "One Way to Implement a Transaction State Machine"
msgstr "トランザクションステートマシンを実装する方法の一つ"

#: ../../sdk/new-protocol-plugins.en.rst:194
msgid ""
"**Transaction state machines** (**TSMs**) in the Protocol plugin must do "
"the following:"
msgstr ""
"プロトコルプラグインの **トランザクションステートマシン** （ **TSM** ）は下"
"記のようにする必要があります。"

#: ../../sdk/new-protocol-plugins.en.rst:197
msgid "Keep track of the state of the transaction"
msgstr "トランザクションの状態を追跡し続ける"

#: ../../sdk/new-protocol-plugins.en.rst:199
msgid ""
"Handle events received (based on the state of the transaction and the event "
"received)"
msgstr ""
"（トランザクションの状態と受け取ったイベントに基づき）受け取ったイベントを処"
"理する"

#: ../../sdk/new-protocol-plugins.en.rst:202
msgid "Update the state of the transaction as it changes"
msgstr "変更があったらトランザクションの状態を更新する"

#: ../../sdk/new-protocol-plugins.en.rst:204
msgid ""
"Below is one way you can implement TSMs. Details about how the Protocol "
"plugin does this are provided in the next section."
msgstr ""
"以下は TSM を実装できる方法の一つです。プロトコルプラグインがこれをどう行っ"
"ているかの詳細は次の節で説明します。"

#: ../../sdk/new-protocol-plugins.en.rst:207
msgid ""
"Create a data structure for transactions that contains all of the state "
"data you need to keep track of. In the Protocol plugin this is a struct, "
"``Txn_SM``."
msgstr ""
"追跡し続ける必要のある全ての状態データを含む、トランザクションのデータ構造を"
"作成する。サンプルのプロトコルプラグインにおいてこれは ``Txn_SM`` 構造体。"

#: ../../sdk/new-protocol-plugins.en.rst:211
msgid ""
"When you create the TSM's continuation, initialize data of type ``Txn_SM``. "
"Initialize the data to the initial state of a transaction (in this case, a "
"net connection has just been accepted). Associate this data to the TSM "
"continuation using ``TSContDataSet``."
msgstr ""
"TSM の継続を作成する際、``Txn_SM`` 型のデータを初期化する。データをトランザ"
"クションの初期状態に初期化する。（この場合、ネットコネクションはちょうど "
"accept されている）このデータを ``TSContDataSet`` を使って TSM 継続に関連付"
"ける。"

#: ../../sdk/new-protocol-plugins.en.rst:216
msgid ""
"Write state handler functions that handle the expected events for each "
"state."
msgstr ""
"状態ごとに予想されるイベントを処理する、状態ハンドラー関数を記述する。"

#: ../../sdk/new-protocol-plugins.en.rst:219
msgid ""
"Write the handler for the TSM. Its job is to receive events, examine the "
"current state, and execute the appropriate state handler function. In the "
"Protocol plugin, the handler is ``main_handler``. ``main_handler`` calls "
"the state handler functions to handle each state."
msgstr ""
"TSM のハンドラーを記述する。そのジョブはイベントを受け取る、現在の状態を検査"
"する、そして適切な状態ハンドラー関数を実行する。プロトコルプラグインにおい"
"て、そのハンドラーは ``main_handler`` である。 ``main_handler`` は各状態を処"
"理するために状態ハンドラー関数を呼び出す。"

#: ../../sdk/new-protocol-plugins.en.rst:262
msgid "How Transaction State Machines are Implemented in the Protocol Plugin"
msgstr ""
"プロトコルプラグインにおいてトランザクションステートマシンがどのように実装さ"
"れるか"

#: ../../sdk/new-protocol-plugins.en.rst:265
msgid "Processing a Typical Transaction"
msgstr "典型的なトランザクションの処理"

#: ../../sdk/new-protocol-plugins.en.rst:267
msgid "The code is contained in the following files:"
msgstr "コードは下記のファイルに含まれます。:"

#: ../../sdk/new-protocol-plugins.en.rst:269
msgid "``Protocol.c`` and ``Protocol.h``"
msgstr "``Protocol.c`` と ``Protocol.h``"

#: ../../sdk/new-protocol-plugins.en.rst:271
msgid "``Accept.c`` and ``Accept.h``"
msgstr "``Accept.c`` と ``Accept.h``"

#: ../../sdk/new-protocol-plugins.en.rst:273
msgid "``TxnSM.c`` and ``TxnSM.h``"
msgstr "``TxnSM.c`` と ``TxnSM.h``"

#: ../../sdk/new-protocol-plugins.en.rst:275
msgid ""
"Below is a step-by-step walk-through of the code that processes a typical "
"transaction."
msgstr ""
"下記は典型的なトランザクションを処理するコードの、段階的なウォークスルーで"
"す。"

#: ../../sdk/new-protocol-plugins.en.rst:278
msgid ""
"The ``TSPluginInit`` function is in the ``Protocol.c`` file. It checks the "
"validity of the ``plugin.config`` entries (there must be two: a client "
"accept port and a server port) and runs an initialization routine, ``init``."
msgstr ""
"``TSPluginInit`` 関数は ``Protocol.c`` ファイルにあります。これは ``plugin."
"config`` のエントリの正当性（クライアント accept ポートとサーバーポートの二"
"つが存在しなければならない）をチェックし、初期化ルーチン ``init`` を実行しま"
"す。"

#: ../../sdk/new-protocol-plugins.en.rst:43
msgid ""
"Using the Protocol plugin, Traffic Server can accept these requests, parse "
"them, and act as a proxy cache (i.e., request the file from the origin "
"server on the client's behalf and store copies of response messages in "
"cache). The Protocol plugin is a state machine that flows through the "
"states illustrated in the :ref:`Sample Protocol State Diagram "
"<SampleProtocolStDiag>`. This figure illustrates the steps that Traffic "
"Server and the Protocol plugin go through in order to support the sample "
"protocol."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:73
msgid "**Sample Protocol State Diagram**"
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:85
msgid ""
"To see how the Protocol plugin works, you need to understand some broader "
"concepts. This section assumes you're familiar with the concepts of :term:"
"`continuation`, Traffic Server's **asynchronous event model**, and basic "
"Traffic Server **plugin structure**. If you are not familiar with these "
"concepts, then reference :ref:`Getting Started <sdk-getting-started>` and :"
"doc:`How to Create Traffic Server Plugins <how-to-create-trafficserver-"
"plugins.en>`"
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:96
msgid ""
"The Protocol plugin creates a static continuation that is an **\"accept\" "
"state machine** - that is, a state machine whose job is to accept client "
"connections on the appropriate port. When Traffic Server accepts a net "
"connection from a client on that port, the accept state machine is "
"activated. It then creates a new continuation: a transaction state machine. "
"The accept state machine creates one transaction state machine for each "
"transaction (where a :term:`transaction` consists of a client request and "
"Traffic Server's response). Each transaction state machine lives until the "
"transaction completes; then it is destroyed. If the client's request for "
"content is a cache miss, then a transaction state machine might need to "
"open a connection to the origin server. This is illustrated in the :ref:"
"`Protocol Plugin Overview <ProtocolPluginOverview>` diagram below."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:174
msgid ""
"The flow of events is illustrated in the :ref:`Protocol Plugin Flow of "
"Events <ProtocolPluginFlow>` diagram above. The thin straight lines show "
"Net Processor event flow, the thin dashed lines represent Host Database "
"event flow, and the thick dashed lines show Cache event flow."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:225
msgid ""
"The steps below describe the flow of execution illustrated in :ref:`\"How "
"Transaction State Machines are Implemented in the Protocol Plugin\" "
"<ImplementTransStMachine>`."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:254
msgid ""
"**How Transaction State Machines are Implemented in the Protocol Plugin**"
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:229
msgid ""
"The handler for the TSM, (called ``main_handler`` in the Protocol plugin) "
"receives events from the TSM."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:232
msgid ""
"``main_handler`` examines the state of the transaction-in particular, it "
"examines the current handler."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:235
msgid ""
"``main_handler`` calls the ``current_handler`` (which is one of the state "
"handler functions), and then passes the current event to "
"``current_handler``. In :ref:`the image below <ImplementTransStMachine>` "
"below, the current handler is called ``state2_handler``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:241
msgid ""
"The ``current_handler`` handles the event and updates the data. In :ref:"
"`the image below <ImplementTransStMachine>` below, the state is changed "
"from ``state2`` to ``state3`` (and the current handler is changed from "
"``state2_handler`` to ``state3_handler``). The next time ``main_handler`` "
"receives an event, it will be processed by ``state3_handler``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:248
msgid ""
"``state2_handler`` arranges the next callback of the TSM. Typically, it "
"gives Traffic Server additional work to do (such as writing a file to "
"cache) so that it can progress to the next state. The TSM "
"(``main_handler``) then waits for the next event to arrive from Traffic "
"Server."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:283
msgid ""
"The ``init`` function (in ``Protocol.c``) creates the plugin's log file "
"using ``TSTextLogObjectCreate``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:286
msgid ""
"The ``init`` function creates the accept state machine using "
"``AcceptCreate``. The code for ``AcceptCreate`` is in the ``Accept.c`` file."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:290
msgid ""
"The accept state machine, like the transaction state machine, keeps track "
"of its state with a data structure. This data structure, ``Accept``, is "
"defined in the ``Accept.h`` file. State data in ``AcceptCreate`` is "
"associated with the new accept state machine via ``TSContDataSet``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:296
msgid ""
"The ``init`` function arranges the callback of the accept state machine "
"when there is a network connection by using ``TSNetAccept``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:300
msgid ""
"The handler for the accept state machine is ``accept_event`` in the "
"``Accept.c`` file. When Traffic Server's Net Processor sends "
"``TS_EVENT_NET_ACCEPT`` to the accept state machine, ``accept_event`` "
"creates a transaction state machine (``txn_sm``) by calling "
"``TxnSMCreate``. Notice that ``accept_event`` creates a mutex for the "
"transaction state machine, since each transaction state machine has its own "
"mutex."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:308
msgid ""
"The ``TxnSMCreate`` function is in the ``TxnSM.c`` file. The first thing it "
"does is initialize the transaction's data, which is of type ``TxnSM`` (as "
"defined in ``TxnSM.h``). Notice that the current handler "
"(``q_current_handler``) is set to ``state_start``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:314
msgid ""
"``TxnSMCreate`` then creates a transaction state machine using "
"``TSContCreate``. The handler for the transaction state machine is "
"``main_handler``, which is in the ``TxnSM.c`` file."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:318
msgid ""
"When ``accept_event`` receives ``TS_EVENT_NET_ACCEPT``, it calls the "
"transaction state machine ( ``TSContCall (txn_sm, 0, NULL);`` ). The event "
"passed to ``main_handler`` is ``0`` (``TS_EVENT_NONE``)."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:323
msgid ""
"The first thing ``main_handler`` does is examine the current ``txn_sm`` "
"state by calling ``TSContDataGet``. The state is ``state_start``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:327
msgid ""
"``main_handler`` then invokes the handler for ``state_start`` by using the "
"function pointer ``TxnSMHandler`` (as defined in ``TxnSM.h``)."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:331
msgid ""
"The ``state_start`` handler function (in the ``TxnSM.c`` file) is handed an "
"event (at this stage, the event is ``TS_EVENT_NET_ACCEPT``) and a client "
"vconnection. ``state_start`` checks to see if this client vconnection is "
"closed; if it is not, then ``state_start`` attempts to read data from the "
"client vconnection into an ``TSIOBuffer`` (``state_start`` is handling the "
"event it receives)."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:339
msgid ""
"``state_start`` changes the current handler to "
"``state_interface_with_client`` (that is, it updates the state of the "
"transaction to the next state)."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:343
msgid ""
"``state_start`` initiates a read of the client vconnection (arranges for "
"Traffic Server to send ``TS_EVENT_VCONN_READ_READY`` events to the TSM) by "
"calling ``TSVConnRead``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:348
msgid ""
"``state_interface_with_client`` is activated by the next event from Traffic "
"Server. It checks for errors and examines the read VIO for the read "
"operation initiated by ``TSVConnRead``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:352
msgid ""
"If the read VIO is the ``client_read_VIO`` (which we are expecting at this "
"stage in the transaction), then ``state_interface_with_client`` updates the "
"state to ``state_read_request_from_client`` ."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:357
msgid ""
"``state_read_request_from_client`` handles actual ``TS_EVENT_READ_READY`` "
"events and reads the client request."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:360
msgid "``state_read_request_from_client`` parses the client request."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:362
msgid ""
"``state_read_request_from_client`` updates the current state to the next "
"state, ``state_handle_cache_lookup`` ."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:365
msgid ""
"``state_read_request_from_client`` arranges for Traffic Server to call back "
"the TSM with the next set of events (initiating the cache lookup) by "
"calling ``TSCacheRead``."
msgstr ""

#: ../../sdk/new-protocol-plugins.en.rst:369
msgid ""
"When the ``TSCacheRead`` sends the TSM either ``TS_EVENT_OPEN_READ`` (a "
"cache hit) or ``TS_EVENT_OPEN_READ_FAILED`` (a cache miss), "
"``main_handler`` calls ``state_handle_cache_lookup``."
msgstr ""

#~ msgid ""
#~ "The handler for the TSM, (called **``main_handler``** in the Protocol "
#~ "plugin) receives events from the TSM."
#~ msgstr ""
#~ "TSM のハンドラー（プロトコルプラグインの **``main_handler``** に呼び出さ"
#~ "れる）は TSM からのイベントを受け取ります。"

#~ msgid ""
#~ "**``main_handler``** examines the state of the transaction-in "
#~ "particular, it examines the current handler."
#~ msgstr ""
#~ "**``main_handler``** は特定のトランザクションの状態を検査します。これは "
#~ "current handler を検査することで行います。"

#~ msgid ""
#~ "**``state2_handler``** arranges the next callback of the TSM. Typically, "
#~ "it gives Traffic Server additional work to do (such as writing a file to "
#~ "cache) so that it can progress to the next state. The TSM "
#~ "(**``main_handler``**) then waits for the next event to arrive from "
#~ "Traffic Server."
#~ msgstr ""
#~ "**``state2_handler``** は次の TSM のコールバックを準備します。一般的に、"
#~ "次の状態に進行できるよう、 Traffic Server に実行すべき追加の作業（キャッ"
#~ "シュにファイルを書込むような）を与えます。 TSM（ **``main_handler``** ）"
#~ "はその後 Traffic Server から届く次のイベントを待ちます。"

#~ msgid ""
#~ "The **``init``** function (in ``Protocol.c``) creates the plugin's log "
#~ "file using **``TSTextLogObjectCreate``**."
#~ msgstr ""
#~ "**``init``** 関数（ ``Protocol.c`` 内）はプラグインのログファイルを "
#~ "**``TSTextLogObjectCreate``** を使って生成します。"

#~ msgid ""
#~ "The **``init``** function creates the accept state machine using "
#~ "**``AcceptCreate``**. The code for **``AcceptCreate``** is in the "
#~ "``Accept.c`` file."
#~ msgstr ""
#~ "**``init``** 関数は **``AcceptCreate``** を使って accept ステートマシンを"
#~ "生成します。 **``AcceptCreate``**  のコードは ``Accept.c`` にあります。"

#~ msgid ""
#~ "The accept state machine, like the transaction state machine, keeps "
#~ "track of its state with a data structure. This data structure, "
#~ "**``Accept``**, is defined in the ``Accept.h`` file. State data in "
#~ "**``AcceptCreate``** is associated with the new accept state machine via "
#~ "**``TSContDataSet``**."
#~ msgstr ""
#~ "accept ステートマシンはトランザクションステートマシンと同様、その状態を"
#~ "データ構造と共に追跡し続けます。このデータ構造、 **``Accept``** は "
#~ "``Accept.h`` ファイルに定義されています。 **``AcceptCreate``** の状態デー"
#~ "タは **``TSContDataSet``** から新しい accept ステートマシンに関連付けられ"
#~ "ます。"

#~ msgid ""
#~ "The **``init``** function arranges the callback of the accept state "
#~ "machine when there is a network connection by using **``TSNetAccept``**."
#~ msgstr ""
#~ "**``TSNetAccept``** を使用することによって、ネットワークコネクションが存"
#~ "在する際、 **``init``** 関数は accept ステートマシンのコールバックを準備"
#~ "します。"

#~ msgid ""
#~ "The handler for the accept state machine is **``accept_event``** in the "
#~ "``Accept.c`` file. When Traffic Server's Net Processor sends "
#~ "**``TS_EVENT_NET_ACCEPT``** to the accept state machine, "
#~ "**``accept_event``** creates a transaction state machine "
#~ "(**``txn_sm``**) by calling **``TxnSMCreate``**. Notice that "
#~ "**``accept_event``** creates a mutex for the transaction state machine, "
#~ "since each transaction state machine has its own mutex."
#~ msgstr ""
#~ "accept ステートマシンのハンドラーは ``Accept.c`` ファイルの "
#~ "**``accept_event``** です。 Traffic Server のネットプロセッサーが accept "
#~ "ステートマシンに **``TS_EVENT_NET_ACCEPT``** を送る際、"
#~ "**``accept_event``** は **``TxnSMCreate``** を呼び出すことによってトラン"
#~ "ザクションステートマシン （ **``txn_sm``** ）を生成します。各トランザク"
#~ "ションステーンは自身のミューテックスを持つので、 **``accept_event``** は"
#~ "トランザクションステートマシンのミューテックスを生成することに注意してく"
#~ "ださい。"

#~ msgid ""
#~ "The **``TxnSMCreate``** function is in the ``TxnSM.c`` file. The first "
#~ "thing it does is initialize the transaction's data, which is of type "
#~ "``TxnSM`` (as defined in ``TxnSM.h``). Notice that the current handler "
#~ "(**``q_current_handler``**) is set to **``state_start``**."
#~ msgstr ""
#~ "**``TxnSMCreate``** 関数は ``TxnSM.c`` ファイルにあります。これが行う最初"
#~ "の処理は、 ``TxnSM`` （ ``TxnSM.h`` で定義される） 型のトランザクション"
#~ "データを初期化することです。 current handler "
#~ "（ **``q_current_handler``** ）は **``state_start``** にセットされること"
#~ "に注意してください。"

#~ msgid ""
#~ "**``TxnSMCreate``** then creates a transaction state machine using "
#~ "**``TSContCreate``**. The handler for the transaction state machine is "
#~ "**``main_handler``**, which is in the ``TxnSM.c`` file."
#~ msgstr ""
#~ "**``TxnSMCreate``** はその後 **``TSContCreate``** を使用してトランザク"
#~ "ションステートマシンを生成します。トランザクションステートマシンのハンド"
#~ "ラーは ``TxnSM.c`` ファイルにある **``main_handler``** です。"

#~ msgid ""
#~ "When **``accept_event``** receives **``TS_EVENT_NET_ACCEPT``**, it calls "
#~ "the transaction state machine ( **``TSContCall (txn_sm, 0, NULL);``** ). "
#~ "The event passed to **``main_handler``** is ``0`` "
#~ "(**``TS_EVENT_NONE``**)."
#~ msgstr ""
#~ "**``accept_event``** が **``TS_EVENT_NET_ACCEPT``** を受け取る際、トラン"
#~ "ザクションステートマシンを呼び出します。（ **``TSContCall (txn_sm, 0, "
#~ "NULL);``** ） **``main_handler``** に渡されるイベントは ``0`` "
#~ "（**``TS_EVENT_NONE``** ）です。"

#~ msgid ""
#~ "The first thing **``main_handler``** does is examine the current "
#~ "**``txn_sm``** state by calling **``TSContDataGet``**. The state is "
#~ "**``state_start``**."
#~ msgstr ""
#~ "**``main_handler``** が行う最初の処理は、 **``TSContDataGet``** を呼び出"
#~ "すことで現在の **``txn_sm``** 状態を検査することです。状態は "
#~ "**``state_start``**です。"

#~ msgid ""
#~ "**``main_handler``** then invokes the handler for **``state_start``** by "
#~ "using the function pointer **``TxnSMHandler``** (as defined in ``TxnSM."
#~ "h``)."
#~ msgstr ""
#~ "**``main_handler``** はその後 **``TxnSMHandler``** （ ``TxnSM.h`` で定義"
#~ "される）関数ポインタを使用することで、**``state_start``** のハンドラーを"
#~ "呼び出します。"

#~ msgid ""
#~ "The **``state_start``** handler function (in the ``TxnSM.c`` file) is "
#~ "handed an event (at this stage, the event is "
#~ "**``TS_EVENT_NET_ACCEPT``**) and a client vconnection. "
#~ "**``state_start``** checks to see if this client vconnection is closed; "
#~ "if it is not, then **``state_start``** attempts to read data from the "
#~ "client vconnection into an **``TSIOBuffer``** (**``state_start``** is "
#~ "handling the event it receives)."
#~ msgstr ""
#~ "**``state_start``** ハンドラー関数（ ``TxnSM.c`` ファイル内）はイベント"
#~ "（この段階で、イベントは **``TS_EVENT_NET_ACCEPT``** になる）と クライア"
#~ "ント vconnection が渡されます。 **``state_start``** はこのクライアント "
#~ "vconnection が close されているか確認する為のチェックを行います。もし "
#~ "close されていなければ、 **``state_start``** はクライアント vconnection "
#~ "から **``TSIOBuffer``** へデータの読込みを試みます。"
#~ "（ **``state_start``** は受け取ったイベントを処理します。）"

#~ msgid ""
#~ "**``state_start``** changes the current handler to "
#~ "**``state_interface_with_client``** (that is, it updates the state of "
#~ "the transaction to the next state)."
#~ msgstr ""
#~ "**``state_start``** は current handler を "
#~ "**``state_interface_with_client``** へ変更します。（これによりトランザク"
#~ "ションの状態を次の状態へ更新します。）"

#~ msgid ""
#~ "**``state_start``** initiates a read of the client vconnection (arranges "
#~ "for Traffic Server to send **``TS_EVENT_VCONN_READ_READY``** events to "
#~ "the TSM) by calling **``TSVConnRead``**."
#~ msgstr ""
#~ "**``state_start``** は **``TSVConnRead``** を呼び出すことによって、"
#~ "（ **``TS_EVENT_VCONN_READ_READY``** イベントを TSM へ送信するよう "
#~ "Traffic Server を準備する）クライアント vconnection の読込みを開始しま"
#~ "す。"

#~ msgid ""
#~ "**``state_interface_with_client``** is activated by the next event from "
#~ "Traffic Server. It checks for errors and examines the read VIO for the "
#~ "read operation initiated by **``TSVConnRead``**."
#~ msgstr ""
#~ "**``state_interface_with_client``** は Traffic Server からの次のイベント"
#~ "によって始動します。これはエラーをチェックし、 **``TSVConnRead``** によっ"
#~ "て開始される読込み操作の read VIO を検査します。"

#~ msgid ""
#~ "If the read VIO is the **``client_read_VIO``** (which we are expecting "
#~ "at this stage in the transaction), then "
#~ "**``state_interface_with_client``** updates the state to "
#~ "**``state_read_request_from_client``** ."
#~ msgstr ""
#~ "read VIO が **``client_read_VIO``** （トランザクションのこの段階で想定さ"
#~ "れるもの）である場合、 **``state_interface_with_client``** は状態を "
#~ "**``state_read_request_from_client``** へ更新します。"

#~ msgid ""
#~ "**``state_read_request_from_client``** handles actual "
#~ "**``TS_EVENT_READ_READY``** events and reads the client request."
#~ msgstr ""
#~ "**``state_read_request_from_client``** は実際の "
#~ "**``TS_EVENT_READ_READY``** イベントを処理し、クライアントリクエストを読"
#~ "み込みます。"

#~ msgid "**``state_read_request_from_client``** parses the client request."
#~ msgstr ""
#~ "**``state_read_request_from_client``** はクライアントリクエストをパースし"
#~ "ます。"

#~ msgid ""
#~ "**``state_read_request_from_client``** updates the current state to the "
#~ "next state, **``state_handle_cache_lookup``** ."
#~ msgstr ""
#~ "**``state_read_request_from_client``** は現在の状態を次の状態、 "
#~ "**``state_handle_cache_lookup``** へ更新します。"

#~ msgid ""
#~ "**``state_read_request_from_client``** arranges for Traffic Server to "
#~ "call back the TSM with the next set of events (initiating the cache "
#~ "lookup) by calling **``TSCacheRead``**."
#~ msgstr ""
#~ "**``state_read_request_from_client``** は **``TSCacheRead``** を呼び出す"
#~ "ことによって次のイベントのセット（キャッシュルックアップの初期化）と共に "
#~ "TSM をコールバックするよう Traffic Server を準備します。"

#~ msgid ""
#~ "When the **``TSCacheRead``** sends the TSM either "
#~ "**``TS_EVENT_OPEN_READ``** (a cache hit) or "
#~ "**``TS_EVENT_OPEN_READ_FAILED``** (a cache miss), **``main_handler``** "
#~ "calls **``state_handle_cache_lookup``**."
#~ msgstr ""
#~ "**``TSCacheRead``** が TMS へ **``TS_EVENT_OPEN_READ``** （キャッシュヒッ"
#~ "ト）もしくは **``TS_EVENT_OPEN_READ_FAILED``** （キャッシュミス）を送信す"
#~ "る際、 **``main_handler``** は **``state_handle_cache_lookup``** を呼び出"
#~ "します。"

#~ msgid ""
#~ "Using the Protocol plugin, Traffic Server can accept these requests, "
#~ "parse them, and act as a proxy cache (i.e., request the file from the "
#~ "origin server on the client's behalf and store copies of response "
#~ "messages in cache). The Protocol plugin is a state machine that flows "
#~ "through the states illustrated in the `Sample Protocol State Diagram "
#~ "<#SampleProtocolStDiag>`_. This figure illustrates the steps that "
#~ "Traffic Server and the Protocol plugin go through in order to support "
#~ "the sample protocol."
#~ msgstr ""
#~ "プロトコルプラグインを使用することで、 Traffic Server はこれらのリクエス"
#~ "トを受け入れ、パースし、プロキシキャッシュとして振る舞う（すなわち、クラ"
#~ "イアントの代わりにオリジンサーバーのファイルをリクエストし、レスポンス"
#~ "メッセージのコピーをキャッシュに保存する）ことができます。プロトコルプラ"
#~ "グインは `サンプルプロトコルの状態遷移図 <#SampleProtocolStDiag>`_ に図示"
#~ "される状態を遷移するステートマシンです。この図はサンプルプロトコルをサ"
#~ "ポートするために Traffic Server とプロトコルプラグインが通過するステップ"
#~ "を図示しています。"

#~ msgid "**Sample Protocol State Diagram** {#SampleProtocolStDiag}"
#~ msgstr "**サンプルプロトコルの状態遷移図** {#SampleProtocolStDiag}"

#~ msgid ""
#~ "To see how the Protocol plugin works, you need to understand some "
#~ "broader concepts. This section assumes you're familiar with the concepts "
#~ "of :term:`continuation`, Traffic Server's **asynchronous event model**, "
#~ "and basic Traffic Server **plugin structure**. If you are not familiar "
#~ "with these concepts, then reference `Getting Started <../getting-"
#~ "started#GettingStarted>`_ and `How to Create Traffic Server Plugins <../"
#~ "how-to-create-trafficserver-plugins>`_"
#~ msgstr ""
#~ "プロトコルプラグインがどのように動作するか理解するため、幾つかの上位概念"
#~ "を理解する必要があります。この節では :term:`継続` 、 Traffic Server の **"
#~ "非同期イベントモデル** 、そして基本的な Traffic Server の **プラグイン構"
#~ "造** の概念に詳しい事を仮定します。これらの概念に詳しくない場合、 `はじめ"
#~ "に <../getting-started#GettingStarted>`_ と `Traffic Server プラグインの"
#~ "作成方法 <../how-to-create-trafficserver-plugins>`_ を参照してください。"

#~ msgid ""
#~ "The Protocol plugin creates a static continuation that is an **\"accept"
#~ "\" state machine** - that is, a state machine whose job is to accept "
#~ "client connections on the appropriate port. When Traffic Server accepts "
#~ "a net connection from a client on that port, the accept state machine is "
#~ "activated. It then creates a new continuation: a transaction state "
#~ "machine. The accept state machine creates one transaction state machine "
#~ "for each transaction (where a :term:`transaction` consists of a client "
#~ "request and Traffic Server's response). Each transaction state machine "
#~ "lives until the transaction completes; then it is destroyed. If the "
#~ "client's request for content is a cache miss, then a transaction state "
#~ "machine might need to open a connection to the origin server. This is "
#~ "illustrated in the `Protocol Plugin Overview "
#~ "<#ProtocolPluginOverview>`__ diagram below."
#~ msgstr ""
#~ "プロトコルプラグインは **\"accept\" ステートマシン** の静的な継続を作成し"
#~ "ます。これは適切なポートでクライアントコネクションを accept する役割を持"
#~ "つステートマシンです。 Traffic Server がそのポートでクライアントからの"
#~ "ネットコネクションを accept する際に accept ステートマシンは動作します。"
#~ "これは新たな継続、トランザクションステートマシンを生成します。 accept ス"
#~ "テートマシンはトランザクションごとに一つのトランザクションステートマシン"
#~ "を生成します。（ :term:`トランザクション` はクライアントリクエストと "
#~ "Traffic Server のレスポンスで成り立ちます）各トランザクションステートマシ"
#~ "ンはトランザクションが完了するまで残り、その後破棄されます。クライアント"
#~ "のコンテンツに対するリクエストがキャッシュミスする場合、トランザクション"
#~ "ステートマシンはオリジンサーバーへのコネクションを開く必要がある可能性が"
#~ "あります。これは下記の `プロトコルプラグイン概要 "
#~ "<#ProtocolPluginOverview>`__ の図に示されています。"

#~ msgid ""
#~ "The flow of events is illustrated in the `Protocol Plugin Flow of Events "
#~ "<#ProtocolPluginFlow>`_ diagram above. The thin straight lines show Net "
#~ "Processor event flow, the thin dashed lines represent Host Database "
#~ "event flow, and the thick dashed lines show Cache event flow."
#~ msgstr ""
#~ "イベントのフローは上の `プロトコルプラグインのイベントのフロー "
#~ "<#ProtocolPluginFlow>`_ の図に示されています。細い直線はネットプロセッ"
#~ "サーのイベントフローを、細い破線はホストデータベースイベントフローを、太"
#~ "い破線はキャッシュイベントフローを示します。"

#~ msgid ""
#~ "The steps below describe the flow of execution illustrated in `\"How "
#~ "Transaction State Machines are Implemented in the Protocol Plugin\" "
#~ "<#ImplementTransStMachine>`__."
#~ msgstr ""
#~ "下記のステップは `\"プロトコルプラグインにおいてトランザクションステート"
#~ "マシンがどのように実装されるか\" <#ImplementTransStMachine>`__ で図示され"
#~ "る実行のフローを説明します。"

#~ msgid ""
#~ "**``main_handler``** calls the **``current_handler``** (which is one of "
#~ "the state handler functions), and then passes the current event to "
#~ "**``current_handler``**. In `the image below "
#~ "<#ImplementTransStMachine>`__ below, the current handler is called "
#~ "**``state2_handler``**."
#~ msgstr ""
#~ "**``main_handler``** は **``current_handler``** （状態ハンドラー関数のひ"
#~ "とつ）を呼び出し、現在のイベントを **``current_handler``** に渡します。下"
#~ "記の `下の図 <#ImplementTransStMachine>`__ で、 current handler は "
#~ "**``state2_handler``** です。"

#~ msgid ""
#~ "The **``current_handler``** handles the event and updates the data. In "
#~ "`the image below <#ImplementTransStMachine>`__ below, the state is "
#~ "changed from **``state2``** to **``state3``** (and the current handler "
#~ "is changed from **``state2_handler``** to **``state3_handler``**). The "
#~ "next time **``main_handler``** receives an event, it will be processed "
#~ "by **``state3_handler``**."
#~ msgstr ""
#~ "**``current_handler``** はイベントを処理しデータを更新します。下記の `下"
#~ "の図 <#ImplementTransStMachine>`__ で、状態は **``state2``** から "
#~ "**``state3``** へ変更されます。（そして current handler は "
#~ "**``state2_handler``** から **``state3_handler``** へ変更されます）次回 "
#~ "**``main_handler``** がイベントを受け取ると、 **``state3_handler``** に"
#~ "よって処理されます。"

#~ msgid ""
#~ "**How Transaction State Machines are Implemented in the Protocol "
#~ "Plugin** {#ImplementTransStMachine}"
#~ msgstr ""
#~ "**プロトコルプラグインにおいてトランザクションステートマシンがどのように"
#~ "実装されるか** {#ImplementTransStMachine}"
